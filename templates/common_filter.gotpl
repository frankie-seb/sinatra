// Code generated by Frankie Health Generator, DO NOT EDIT.

package {{.PackageName}}

import (
	"context"
	"fmt"
	"io"
	"strconv"
	"time"
	"reflect"
	"unsafe"
	"sync"
	"errors"
	"bytes"
	"strings"
	base_helpers "github.com/frankie-seb/sinatra/helpers"
	"github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/volatiletech/sqlboiler/v4/drivers"
	"github.com/ericlagergren/decimal"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/null/v8"
	"database/sql"
	{{ range $import := .Imports }}
		{{ $import.Alias }} "{{ $import.ImportPath }}"
	{{ end }}
)



// const regexSign = `'`
const percentSign = `%`

const parentTableStatement = "%v.%v = %v.%v"
func startsWithValue(v string) string { return   v + percentSign   }
func endsWithValue(v string) string   { return   percentSign + v  }
func containsValue(v string) string   { return   percentSign + v + percentSign   }

const emptyString = "''"
const isZero = "0"
const isLike = " LIKE ?"
const in = " IN ?"
const notIn = " NOT IN ?"

func isNullOr(column string, v string) qm.QueryMod {
	return qm.Where("("+column+" IS NULL OR "+column+" != "+v+")")
}

func isNotNullOr(column string, v string) qm.QueryMod {
	return qm.Where("("+column+" IS NOT NULL AND "+column+" != "+v+")")
}

func appendSubQuery(queryMods []qm.QueryMod, q *queries.Query) []qm.QueryMod {
	{{- if $.PluginConfig.PostgresSubModelFiltering }}
		member := reflect.ValueOf(q).Elem().FieldByName("dialect")
		dialectPtr := (**drivers.Dialect)(unsafe.Pointer(member.UnsafeAddr()))
		dialect := **dialectPtr
		dialect.UseIndexPlaceholders = false
		*dialectPtr = &dialect
	{{- end }}

	qs, args := queries.BuildQuery(q)
	qsClean := strings.TrimSuffix(qs, ";")
	return append(queryMods, qm.Where(fmt.Sprintf("EXISTS(%v)", qsClean), args...))
}

func appendJoinSubQuery(queryMods []qm.QueryMod, q *queries.Query, to string, via string, toCol string) []qm.QueryMod {
	{{- if $.PluginConfig.PostgresSubModelFiltering }}
		member := reflect.ValueOf(q).Elem().FieldByName("dialect")
		dialectPtr := (**drivers.Dialect)(unsafe.Pointer(member.UnsafeAddr()))
		dialect := **dialectPtr
		dialect.UseIndexPlaceholders = false
		*dialectPtr = &dialect
	{{- end }}

	qs, args := queries.BuildQuery(q)
	qsClean := strings.TrimSuffix(qs, ";")
	return append(queryMods, qm.Where(fmt.Sprintf("EXISTS(SELECT 1 FROM {{ if $.PluginConfig.Schema }}\"{{ $.PluginConfig.Schema }}\".{{- end }}\"%v\" WHERE (EXISTS(%v AND (%v.%v = %v.id)))", via, qsClean, via, toCol, to), args...))
}

func BooleanFilterToMods(m *{{ $.GqlModels.PackageName }}.BooleanFilter, column string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	if m.IsNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNull(column))
	}
	if m.NotNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNotNull(column))
	}
	if m.EqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, *m.EqualTo))
	}
	if m.NotEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, *m.NotEqualTo))
	}
	return queryMods
}

func IDFilterToMods(m *{{ $.GqlModels.PackageName }}.IDFilter, column string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	if m.IsNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNull(column))
	}
	if m.NotNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNotNull(column))
	}
	if m.EqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, base_helpers.IDToBoiler(*m.EqualTo)))
	}
	if m.NotEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, base_helpers.IDToBoiler(*m.NotEqualTo)))
	}
	if len(m.In) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column + in, base_helpers.IDsToBoilerInterfaces(m.In)...))
	}
	if len(m.NotIn) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column + notIn, base_helpers.IDsToBoilerInterfaces(m.NotIn)...))
	}
	return queryMods
}



func StringFilterToMods(m *{{ $.GqlModels.PackageName }}.StringFilter, column string) []qm.QueryMod {
	if m == nil {
		return nil
	}

	var queryMods []qm.QueryMod
	if m.IsNullOrEmpty != nil {
		queryMods = append(queryMods, isNullOr(column, emptyString))
	}
	if m.IsEmpty != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, emptyString))
	}
	if m.IsNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNull(column))
	}
	if m.NotNullOrEmpty != nil {
		queryMods = append(queryMods, isNotNullOr(column, emptyString))
	}
	if m.NotEmpty != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, emptyString))
	}
	if m.NotNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNotNull(column))
	}
	if m.EqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, *m.EqualTo))
	}
	if m.NotEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, *m.NotEqualTo))
	}

	lowerColumn := "LOWER("+column+")"
	if m.StartWith != nil {
		queryMods = append(queryMods, qm.Where(lowerColumn+isLike, startsWithValue(strings.ToLower(*m.StartWith))))
	}
	if m.EndWith != nil {
		queryMods = append(queryMods, qm.Where(lowerColumn+isLike, endsWithValue(strings.ToLower(*m.EndWith))))
	}
	if m.Contain != nil {
		queryMods = append(queryMods, qm.Where(lowerColumn+isLike, containsValue(strings.ToLower(*m.Contain))))
	}

	if m.StartWithStrict != nil {
		queryMods = append(queryMods, qm.Where(column+isLike, startsWithValue(*m.StartWithStrict)))
	}
	if m.EndWithStrict != nil {
		queryMods = append(queryMods, qm.Where(column+isLike, endsWithValue(*m.EndWithStrict)))
	}
	if m.ContainStrict != nil {
		queryMods = append(queryMods, qm.Where(column+isLike, containsValue(*m.ContainStrict)))
	}

	if len(m.In) > 0 {
		isIdCol := false
		var res []interface{}

		for _, v := range res {
			if v != nil {
				isIdCol = true
			}
		}

		if isIdCol {
			res = base_helpers.IDsToBoilerInterfaces(m.In)
		} else {
			res = base_helpers.StringsToInterfaces(m.In)
		}

		queryMods = append(queryMods, qm.WhereIn(column + in, res...))
	}
	if len(m.NotIn) > 0 {
		isIdCol := false
		var res []interface{}

		for _, v := range res {
			if v != nil {
				isIdCol = true
			}
		}

		if isIdCol {
			res = base_helpers.IDsToBoilerInterfaces(m.In)
		} else {
			res = base_helpers.StringsToInterfaces(m.In)
		}

		queryMods = append(queryMods, qm.WhereIn(column + notIn, res...))
	}
	
	return queryMods
}


func FloatFilterToMods(m *{{ $.GqlModels.PackageName }}.FloatFilter, column string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	if m.IsNullOrZero != nil {
		queryMods = append(queryMods, isNullOr(column, isZero))
	}
	if m.IsNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNull(column))
	}
	if m.NotNullOrZero != nil {
		queryMods = append(queryMods, isNotNullOr(column, isZero))
	}
	if m.NotNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNotNull(column))
	}
	if m.EqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, *m.EqualTo))
	}
	if m.NotEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, *m.NotEqualTo))
	}
	if m.LessThan != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.LT, *m.LessThan))
	}
	if m.MoreThan != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.GT, *m.MoreThan))
	}
	if m.LessThanOrEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.LTE, *m.LessThanOrEqualTo))
	}
	if m.MoreThanOrEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.GTE, *m.MoreThanOrEqualTo))
	}
	if len(m.In) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column + in, base_helpers.FloatsToInterfaces(m.In)...))
	}
	if len(m.NotIn) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column + notIn, base_helpers.FloatsToInterfaces(m.NotIn)...))
	}
	return queryMods
}

func IntFilterToMods(m *{{ $.GqlModels.PackageName }}.IntFilter, column string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	if m.IsNullOrZero != nil {
		queryMods = append(queryMods, isNullOr(column, isZero))
	}
	if m.IsNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNull(column))
	}
	if m.NotNullOrZero != nil {
		queryMods = append(queryMods, isNotNullOr(column, isZero))
	}
	if m.NotNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNotNull(column))
	}
	if m.EqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, *m.EqualTo))
	}
	if m.NotEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, *m.NotEqualTo))
	}
	if m.LessThan != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.LT, *m.LessThan))
	}
	if m.MoreThan != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.GT, *m.MoreThan))
	}
	if m.LessThanOrEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.LTE, *m.LessThanOrEqualTo))
	}
	if m.MoreThanOrEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.GTE, *m.MoreThanOrEqualTo))
	}
	if len(m.In) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column + in, base_helpers.IntsToInterfaces(m.In)...))
	}
	if len(m.NotIn) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column + notIn, base_helpers.IntsToInterfaces(m.NotIn)...))
	}
	return queryMods
}

func TimeFilterToMods(m *{{ $.GqlModels.PackageName }}.TimeFilter, column string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	if m.IsNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNull(column))
	}
	if m.NotNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNotNull(column))
	}
	if m.EqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, *m.EqualTo))
	}
	if m.NotEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, *m.NotEqualTo))
	}
	if m.LessThan != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.LT, *m.LessThan))
	}
	if m.MoreThan != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.GT, *m.MoreThan))
	}
	if m.LessThanOrEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.LTE, *m.LessThanOrEqualTo))
	}
	if m.MoreThanOrEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.GTE, *m.MoreThanOrEqualTo))
	}
	return queryMods
}
