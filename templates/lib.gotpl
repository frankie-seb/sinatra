// Code generated by Frankie Health Generator, DO NOT EDIT.

package {{.PackageName}}

import (
	"context"
	"fmt"
	"io"
	"strconv"
	"time"
	"sync"
	"errors"
	"bytes"
	"strings"

	base_helpers "github.com/frankie-seb/sinatra/helpers"
	"github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"


	"github.com/ericlagergren/decimal"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/null/v8"

	"database/sql"
	{{ range $import := .Imports }}
		{{ $import.Alias }} "{{ $import.ImportPath }}"
	{{ end }}
)

{{ range $enum := .Enums }}
	func NullDotStringToPointer{{ .Name }}(v null.String) *{{ $.GqlModels.PackageName }}.{{ .Name }} {
		s := StringTo{{ .Name }}(v.String)
		if s == "" {
			return nil
		}
		return &s
	}

	func NullDotStringTo{{ .Name }}(v null.String) {{ $.GqlModels.PackageName }}.{{ .Name }} {
		if !v.Valid {
			return ""
		}
		return StringTo{{ .Name }}(v.String)
	}

	func StringTo{{ .Name }}(v string) {{ $.GqlModels.PackageName }}.{{ .Name }} {
		{{- if $enum.HasBoilerEnum }}
			return {{$enum.Name}}APIValue[v]
		{{- else }}
			return {{$enum.Name}}APIValue[{{ .Name }}(v)]
		{{- end }}
	}

	func StringToPointer{{ .Name }}(v string) *{{ $.GqlModels.PackageName }}.{{ .Name }} {
		s := StringTo{{ .Name }}(v)
		if s == "" {
			return nil
		}
		return &s
	}

	func Pointer{{ .Name }}ToString(v *{{ $.GqlModels.PackageName }}.{{ .Name }}) string {
		if v == nil {
			return ""
		}
		return {{ .Name }}ToString(*v)
	}

	func Pointer{{ .Name }}ToNullDotString(v *{{ $.GqlModels.PackageName }}.{{ .Name }}) null.String {
		if v == nil {
			return null.NewString("", false)
		}
		return {{ .Name }}ToNullDotString(*v)
	}

	func {{ .Name }}ToNullDotString(v {{ $.GqlModels.PackageName }}.{{ .Name }}) null.String {
		s := {{ .Name }}ToString(v)
		return null.NewString(s, s != "")
	}

	func {{ .Name }}ToString(v {{ $.GqlModels.PackageName }}.{{ .Name }}) string {
		{{- if $enum.HasBoilerEnum }}
		return {{$enum.Name}}DBValue[v]
		{{- else }}
		return string({{$enum.Name}}DBValue[v])
		{{- end }}
	}

	func {{ .PluralName }}ToInterfaceArray(va []{{ $.GqlModels.PackageName }}.{{ .Name }}) []interface{} {
		var a []interface{}
		for _, v := range va {
			rv, ok := {{ .Name }}DBValue[v]
			if ok {
				a = append(a, rv)
			}
		}
		return a
	}
{{ end }}

{{ range $model := .Models }}

	{{- if .IsInput -}}
		func {{ .PluralName }}ToBoiler(am []*{{ $.GqlModels.PackageName }}.{{ .Name }})( []*{{ $.BoilerModels.PackageName }}.{{ .BoilerModel.Name }}) {
			ar := make([]*{{ $.BoilerModels.PackageName }}.{{ .BoilerModel.Name }}, len(am))
			for i,m := range am {
				ar[i] = {{ .Name }}ToBoiler(
					m,
				)
			}
			return ar
		}
	{{ end }}
	{{- if .IsNormal  -}}
		{{- if .HasPrimaryStringID }}
			func {{ .Name }}WithStringID(id string) *{{ $.GqlModels.PackageName }}.{{ .Name }} {
				return &{{ $.GqlModels.PackageName }}.{{ .Name }}{
					ID: {{ $model.Name }}IDToGraphQL(id),
				}
			}

			func {{ .Name }}WithNullDotStringID(id null.String) *{{ $.GqlModels.PackageName }}.{{ .Name }} {
				return {{ .Name }}WithStringID(id.String)
			}
		{{- else }}
			func {{ .Name }}WithUintID(id uint) *{{ $.GqlModels.PackageName }}.{{ .Name }} {
				return &{{ $.GqlModels.PackageName }}.{{ .Name }}{
					ID: {{ $model.Name }}IDToGraphQL(id),
				}
			}

			func {{ .Name }}WithIntID(id int) *{{ $.GqlModels.PackageName }}.{{ .Name }} {
				return {{ .Name }}WithUintID(uint(id))
			}

			func {{ .Name }}WithNullDotUintID(id null.Uint) *{{ $.GqlModels.PackageName }}.{{ .Name }} {
				return {{ .Name }}WithUintID(id.Uint)
			}

			func {{ .Name }}WithNullDotIntID(id null.Int) *{{ $.GqlModels.PackageName }}.{{ .Name }} {
				return {{ .Name }}WithUintID(uint(id.Int))
			}
			
		{{- end }}

		func {{ .PluralName }}ToGraphQL(am []*{{ $.BoilerModels.PackageName }}.{{ .Name }})( []*{{ $.GqlModels.PackageName }}.{{ .Name }}) {
			ar := make([]*{{ $.GqlModels.PackageName }}.{{ .Name }}, len(am))
			for i,m := range am {
				ar[i] = {{ .Name }}ToGraphQL(m)
			}
			return ar
		}

		{{ range $field := .Fields }}
			{{- if $field.IsPrimaryNumberID -}}
				func {{ $model.Name }}IDToGraphQL(v uint) string {
					return base_helpers.IDToGraphQL(v, {{ $.BoilerModels.PackageName }}.TableNames.{{ $model.BoilerModel.TableName }})
				}
			{{- end -}}
			{{- if $field.IsPrimaryStringID -}}
				func {{ $model.Name }}IDToGraphQL(v string) string {
					return base_helpers.StringIDToGraphQL(v, {{ $.BoilerModels.PackageName }}.TableNames.{{ $model.BoilerModel.TableName }})
				}
			{{- end -}}
		{{- end }}
		{{ range $field := .Fields }}
			{{- if $field.IsPrimaryNumberID }}
				func {{ $model.Name }}ID(v string) {{ $field.BoilerField.Type }} {
					return base_helpers.IDToBoiler{{ $field.BoilerField.Type|go }}(v)
				}

				func {{ $model.Name }}IDs(a []string) []{{ $field.BoilerField.Type }} {
					return base_helpers.IDsToBoiler{{ $field.BoilerField.Type|go }}(a)
				}
				
			{{- end -}}
			{{- if $field.IsPrimaryStringID }}
				func {{ $model.Name }}ID(v string) {{ $field.BoilerField.Type }} {
					return base_helpers.StringIDToBoiler{{ $field.BoilerField.Type|go }}(v)
				}

				func {{ $model.Name }}IDs(a []string) []{{ $field.BoilerField.Type }} {
					return base_helpers.StringIDsToBoiler{{ $field.BoilerField.Type|go }}(a)
				}

			{{- end -}}
		{{- end }}
	{{ end }}
	{{- if .IsFilter -}}
		func {{ .Name }}ToMods(m *{{ $.GqlModels.PackageName }}.{{ .Name }}) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {
				var queryMods []qm.QueryMod
				queryMods  = append(queryMods, {{ .BoilerModel.Name }}SearchToMods(m.Search)...)
				queryMods  = append(queryMods, {{ .BoilerModel.Name }}WhereToMods(m.Where, true, "")...)
				if len(queryMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(queryMods...),
					}
				}
			}
			return nil
		}
		func {{ .BoilerModel.Name }}SearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	{{ end }}
	{{- if .IsWhere  -}}
		func {{ .Name }}SubqueryToMods(m *{{ $.GqlModels.PackageName }}.{{ .Name }}, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := {{ .Name }}ToMods(m, !hasForeignKeyInRoot, parentTable)
			subQuery := {{ $.BoilerModels.PackageName }}.{{.BoilerModel.PluralName}}(append(subQueryMods, qm.Select("1"))...)
			if len(subQueryMods) > 0 {
				if len(subQueryMods) > 0 && parentTable != "" && foreignColumn != "" {
					subQueryMods = append(subQueryMods, qm.Where(fmt.Sprintf("%v.id = %v.%v", models.TableNames.{{ .BoilerModel.Name }}, parentTable, foreignColumn)))
				}
				
				{{- if not .JoinArray }}
				queryMods = appendSubQuery(queryMods, subQuery.Query)
				{{- end}}

				{{- range $value := .JoinArray }}
					if len(subQueryMods) > 0 && parentTable == "{{$value.From}}" && foreignColumn == "" {
						queryMods = appendJoinSubQuery(queryMods, subQuery.Query, "{{$value.To}}", "{{$value.Via}}", "{{$value.ToCol}}")
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("{{$value.From}}.id = {{$value.Via}}.{{$value.FromCol}})")))
					}
				{{- end -}}
			} else if len(subQueryMods) > 0 {
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			
			return queryMods
		} 
	{{ end }}
	{{- if .IsOrdering -}}

        func {{ .BoilerModel.Name }}SortDirection(ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering) base_helpers.SortDirection {
            for _, o := range ordering {
                return o.Direction
            }
            return base_helpers.SortDirectionAsc
        }


		func From{{ .BoilerModel.Name }}Cursor(cursor string, comparisonSign base_helpers.ComparisonSign) []qm.QueryMod {
			var columns []string
			var values []interface{}

			for _, cursorValue := range base_helpers.CursorStringToValues(cursor) {
				column, value := {{ .BoilerModel.Name }}SortValueFromCursorValue(cursorValue)
				if column != "" && value != nil {
					columns = append(columns, column)
					values = append(values, value)
				}
			}

			if len(columns) > 0 {
				return []qm.QueryMod{
					qm.Where(base_helpers.GetCursorWhere(comparisonSign, columns, values), values...),
				}
			}
			return nil
		}

		func To{{ .BoilerModel.Name }}Cursor(ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering, m *{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}) string {
			var a []string
			var handledID bool

			for _, order := range ordering {
				{{- range $field := .Fields -}}
					{{- if eq $field.Name "Sort" -}}
						{{- range $value := $field.Enum.Values -}}
							{{ if eq $value.Name "ID" }}
							if order.Sort == {{ $.GqlModels.PackageName }}.{{ $field.Enum.Name|go }}{{ .Name|go }} {
								handledID = true
							}
							{{ end }}
						{{- end -}}
					{{- end -}}
				{{- end -}}
				value := {{ .BoilerModel.Name }}SortCursorValue(order.Sort, m)
				switch value.(type) {
				case *time.Time:
					value = value.(*time.Time).Local().UTC().Format(time.RFC3339Nano)
				case time.Time:
					value = value.(time.Time).Local().UTC().Format(time.RFC3339Nano)
				}
				if value != nil {
					a = append(a, base_helpers.ToCursorValue(string(order.Sort), value))
				}
			}

			{{- range $field := .Fields -}}
				{{- if eq $field.Name "Sort" -}}
					{{- range $value := $field.Enum.Values}}
						{{ if eq $value.Name "ID" }}
							if !handledID {
								a = append(a, base_helpers.ToCursorValue(string({{ $.GqlModels.PackageName }}.{{ $field.Enum.Name|go }}{{ .Name|go }}), m.ID))
							}
						{{ end }}
				{{- end -}}
				{{- end -}}
			{{- end -}}

		
			return base_helpers.CursorValuesToString(a)
		}

		func {{ .BoilerModel.Name }}CursorType(ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering) base_helpers.CursorType {
			countDirection, result := base_helpers.CursorTypeCounter()
			for _, o := range ordering {
				countDirection(o.Direction)
			}
			return result()
		}

		func {{ .BoilerModel.Name }}CursorMods(ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering, cursor *string, sign base_helpers.ComparisonSign) []qm.QueryMod {
			if cursor != nil {
				if {{ .BoilerModel.Name }}CursorType(ordering) == base_helpers.CursorTypeCursor {
					return From{{ .BoilerModel.Name }}Cursor(*cursor, sign)
				}
				return base_helpers.FromOffsetCursor(*cursor)
			}
			return nil
		}

		func {{ .BoilerModel.Name }}SortMods(ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering, reverse bool, defaultDirection base_helpers.SortDirection) []qm.QueryMod {
			var a []qm.QueryMod

			var handledID bool
			for _, order := range ordering {
				{{- range $field := .Fields -}}
					{{- if eq $field.Name "Sort" -}}
						{{- range $value := $field.Enum.Values -}}
							{{ if eq $value.Name "ID" }}
								if order.Sort == {{ $.GqlModels.PackageName }}.{{ $field.Enum.Name|go }}{{ .Name|go }} {
									handledID = true
								}
							{{ end }}
						{{- end -}}
					{{- end -}}
				{{- end -}}

				column := {{ .BoilerModel.Name }}SortColumn[order.Sort]
				if column != ""  {
					a = append(a, qm.OrderBy(base_helpers.GetOrderBy(
						column,
						base_helpers.GetDirection(order.Direction, reverse),
					)))
				}
				// TODO allow non-postres databases
				if order.Sort == "RANDOM" {
					a = append(a, qm.OrderBy("RANDOM()"))
				}
			}
			if !handledID {
				a = append(a, qm.OrderBy(base_helpers.GetOrderBy(
					{{ $.BoilerModels.PackageName }}.{{ $model.BoilerModel.Name }}Columns.ID,
					base_helpers.GetDirection(defaultDirection, reverse),
				)))
			}
			return a
		}


		func {{ .BoilerModel.Name }}PaginationModsBase(pagination base_helpers.ConnectionPagination, ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering, reverse bool, limit int) (*string, []qm.QueryMod) {
			direction := {{ .BoilerModel.Name }}SortDirection(ordering)
			cursor := base_helpers.GetCursor(pagination.Forward, pagination.Backward)
			sign := base_helpers.GetComparison(pagination.Forward, pagination.Backward, reverse, direction)
		
			var mods []qm.QueryMod
			mods = append(mods, {{ .BoilerModel.Name }}CursorMods(ordering, cursor, sign)...)
			mods = append(mods, {{ .BoilerModel.Name }}SortMods(ordering, reverse, direction)...)
			mods = append(mods, qm.Limit(limit))
			return cursor, mods
		}
		
		func {{ .BoilerModel.Name }}PaginationMods(pagination base_helpers.ConnectionPagination, ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering) ([]qm.QueryMod, error) {
			if pagination.Forward != nil && pagination.Backward != nil {
				return nil, errors.New("can not use forward and backward pagination at once")
			}
			if pagination.Forward == nil && pagination.Backward == nil {
				return nil, errors.New("no forward or backward pagination provided")
			}
		
			reverse := pagination.Backward != nil
			limit := base_helpers.GetLimit(pagination.Forward, pagination.Backward)
			_, mods := {{ .BoilerModel.Name }}PaginationModsBase(pagination, ordering, reverse, limit)
			return mods, nil
		}
		
		func To{{ .BoilerModel.Name }}CursorSwitch(ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering, m *{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}, cursorType base_helpers.CursorType, offset int, index int) string {
			switch cursorType {
			case base_helpers.CursorTypeOffset:
				return base_helpers.ToOffsetCursor(offset + index)
			case base_helpers.CursorTypeCursor:
				return To{{ .BoilerModel.Name }}Cursor(ordering, m)
			}
			return ""
		}
		
		func {{ .BoilerModel.Name }}ReversePageInformation(
			ctx context.Context,
			db boil.ContextExecutor,
			pagination base_helpers.ConnectionPagination,
			ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering,
		) (bool, error) {
			reverse := pagination.Forward != nil
			cursor, reverseMods := {{ .BoilerModel.Name }}PaginationModsBase(pagination, ordering, reverse, 1)
			reverseMods = append(reverseMods, qm.GroupBy("id"))
			cursorType := {{ .BoilerModel.Name }}CursorType(ordering)
			return base_helpers.HasReversePage(cursor, pagination, cursorType, func() (int64, error) {
				return {{ $.BoilerModels.PackageName }}.{{ .BoilerModel.PluralName }}(reverseMods...).Count(ctx, db)
			})
		}
		
		func {{ .BoilerModel.Name }}EdgeConverter(pagination base_helpers.ConnectionPagination, ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering) func(*{{ $.BoilerModels.PackageName }}.{{ .BoilerModel.Name }}, int) *{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Edge {
			cursor, cursorType := base_helpers.GetCursor(pagination.Forward, pagination.Backward), {{ .BoilerModel.Name }}CursorType(ordering)
			offset := base_helpers.GetOffsetFromCursor(cursor)
			return func(m *{{ $.BoilerModels.PackageName }}.{{ .BoilerModel.Name }}, i int) *{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Edge {
				n := {{ .BoilerModel.Name }}ToGraphQL(m)
				return &{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Edge{
					Cursor: To{{ .BoilerModel.Name }}CursorSwitch(ordering, n, cursorType, offset, i),
					Node:   n,
				}
			}
		}
		
		func {{ .BoilerModel.Name }}StartEndCursor(edges []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Edge) (*string, *string) {
			var startCursor, endCursor *string
			if len(edges) >= 2 {
				s, e := edges[0].Cursor, edges[len(edges)-1].Cursor
				startCursor = &s
				endCursor = &e
			} else if len(edges) == 1 {
				c := edges[0].Cursor
				startCursor = &c
				endCursor = &c
			}
			return startCursor, endCursor
		}
		
		func {{ .BoilerModel.Name }}Connection(
			ctx context.Context,
			db boil.ContextExecutor,
			originalMods []qm.QueryMod,
			pagination base_helpers.ConnectionPagination,
			ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering,
		) (*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Connection, error) {
			paginationMods, err := {{ .BoilerModel.Name }}PaginationMods(pagination, ordering)
			if err != nil {
				return nil, err
			}
		
			hasMoreReversed, err := {{ .BoilerModel.Name }}ReversePageInformation(ctx, db, pagination, ordering)
			if err != nil {
				return nil, err
			}
		
			a, err := {{ $.BoilerModels.PackageName }}.{{ .BoilerModel.PluralName }}(append(originalMods, paginationMods...)...).All(ctx, db)
			if err != nil {
				return nil, err
			}

			l := base_helpers.ExistsInContextQuery(ctx, "count")
			var count int
			if l == true && len(originalMods) != 0 {
				c, err := {{ $.BoilerModels.PackageName }}.{{ .BoilerModel.PluralName }}(append(originalMods)...).Count(ctx, db)
				if err != nil {
					return nil, err
				}
				count = int(c)
			}

			edges := make([]*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Edge, 0, base_helpers.EdgeLength(pagination, len(a)))
			edgeConverter := {{ .BoilerModel.Name }}EdgeConverter(pagination, ordering)
			hasMore := base_helpers.BaseConnection(pagination, len(a), func(i int) {
				edges = append(edges, edgeConverter(a[i], i))
			})
			startCursor, endCursor := {{ .BoilerModel.Name }}StartEndCursor(edges)
			hasNextPage, hasPreviousPage := base_helpers.HasNextAndPreviousPage(pagination, hasMore, hasMoreReversed)
			return &{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Connection{
				Count: &count,
				Edges: edges,
				PageInfo: &{{ $.GqlModels.PackageName }}.PageInfo{
					HasNextPage:     hasNextPage,
					HasPreviousPage: hasPreviousPage,
					StartCursor:     startCursor,
					EndCursor:       endCursor,
				},
			}, nil
		}
    {{ end }}
{{- end }}