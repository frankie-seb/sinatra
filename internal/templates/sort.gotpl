// Code generated by Frankie Health Generator, DO NOT EDIT.

package {{.PackageName}}

import (
	"context"
	"fmt"
	"io"
	"strconv"
	"time"
	"sync"
	"errors"
	"bytes"
	"strings"

	base_helpers "github.com/FrankieHealth/be-generator/utils"
	"github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"


	"github.com/ericlagergren/decimal"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/null/v8"

	"database/sql"
	{{ range $import := .Imports }}
		{{ $import.Alias }} "{{ $import.ImportPath }}"
	{{ end }}
)



{{ range $model := .Models }}

        {{- if .IsOrdering -}}

		{{- range $field := .Fields -}}
			{{- if eq $field.Name "Sort" -}}
				var {{ $field.Enum.Name }}Column = map[{{ $.GqlModels.PackageName }}.{{$field.Enum.Name}}]string{
					{{- range $value := $field.Enum.Values}}
						{{ $.GqlModels.PackageName }}.{{ $field.Enum.Name|go }}{{ .Name|go }}: {{ $.BoilerModels.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{ $value.Name|go }},
					{{- end }}
				}

				func {{ $model.BoilerModel.Name }}SortValueFromCursorValue(cursorValue string) (string, interface{}) {
					key, value := base_helpers.FromCursorValue(cursorValue)
					column := {{ $model.BoilerModel.Name }}SortColumn[{{ $.GqlModels.PackageName }}.{{ $model.BoilerModel.Name }}Sort(key)]


					{{ range $value := $field.Enum.Values}}
						{{- if eq $value.Name "ID" -}}
						if {{ $.GqlModels.PackageName }}.{{ $field.Enum.Name|go }}(key) == {{ $.GqlModels.PackageName }}.{{ $field.Enum.Name|go }}{{ .Name|go }} {
							return column, base_helpers.GetIDFromCursor(value)
						}
						{{- end -}}
					{{ end }}

					return column, base_helpers.StringToInterface(value)
				}

				func {{ $model.BoilerModel.Name }}SortCursorValue(sort {{ $.GqlModels.PackageName }}.{{ $model.BoilerModel.Name }}Sort, m *{{ $.GqlModels.PackageName }}.{{ $model.BoilerModel.Name }}) interface{} {
					switch sort {
					{{- range $value := $field.Enum.Values }}
						case {{ $.GqlModels.PackageName }}.{{ $field.Enum.Name|go }}{{ .Name|go }}:
						return m.{{ .Name|go }}
					{{- end }}
					}
					return nil
				}
			{{ end }}
		{{- end }}


        func {{ .BoilerModel.Name }}SortDirection(ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering) base_helpers.SortDirection {
            for _, o := range ordering {
                return o.Direction
            }
            return base_helpers.SortDirectionAsc
        }


		func From{{ .BoilerModel.Name }}Cursor(cursor string, comparisonSign base_helpers.ComparisonSign) []qm.QueryMod {
			var columns []string
			var values []interface{}

			for _, cursorValue := range base_helpers.CursorStringToValues(cursor) {
				column, value := {{ .BoilerModel.Name }}SortValueFromCursorValue(cursorValue)
				if column != "" && value != nil {
					columns = append(columns, column)
					values = append(values, value)
				}
			}

			if len(columns) > 0 {
				return []qm.QueryMod{
					qm.Where(base_helpers.GetCursorWhere(comparisonSign, columns, values), values...),
				}
			}
			return nil
		}

		func To{{ .BoilerModel.Name }}Cursor(ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering, m *{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}) string {
			var a []string
			var handledID bool

			for _, order := range ordering {
				{{- range $field := .Fields -}}
					{{- if eq $field.Name "Sort" -}}
						{{- range $value := $field.Enum.Values -}}
							{{ if eq $value.Name "ID" }}
							if order.Sort == {{ $.GqlModels.PackageName }}.{{ $field.Enum.Name|go }}{{ .Name|go }} {
								handledID = true
							}
							{{ end }}
						{{- end -}}
					{{- end -}}
				{{- end -}}
				value := {{ .BoilerModel.Name }}SortCursorValue(order.Sort, m)
				if value != nil {
					a = append(a, base_helpers.ToCursorValue(string(order.Sort), value))
				}
			}

			{{- range $field := .Fields -}}
				{{- if eq $field.Name "Sort" -}}
					{{- range $value := $field.Enum.Values}}
						{{ if eq $value.Name "ID" }}
							if !handledID {
								a = append(a, base_helpers.ToCursorValue(string({{ $.GqlModels.PackageName }}.{{ $field.Enum.Name|go }}{{ .Name|go }}), m.ID))
							}
						{{ end }}
				{{- end -}}
				{{- end -}}
			{{- end -}}

			return base_helpers.CursorValuesToString(a)
		}

		func {{ .BoilerModel.Name }}CursorType(ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering) base_helpers.CursorType {
			countDirection, result := base_helpers.CursorTypeCounter()
			for _, o := range ordering {
				countDirection(o.Direction)
			}
			return result()
		}

		func {{ .BoilerModel.Name }}CursorMods(ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering, cursor *string, sign base_helpers.ComparisonSign) []qm.QueryMod {
			if cursor != nil {
				if {{ .BoilerModel.Name }}CursorType(ordering) == base_helpers.CursorTypeCursor {
					return From{{ .BoilerModel.Name }}Cursor(*cursor, sign)
				}
				return base_helpers.FromOffsetCursor(*cursor)
			}
			return nil
		}

		func {{ .BoilerModel.Name }}SortMods(ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering, reverse bool, defaultDirection base_helpers.SortDirection) []qm.QueryMod {
			var a []qm.QueryMod

			var handledID bool
			for _, order := range ordering {
				{{- range $field := .Fields -}}
					{{- if eq $field.Name "Sort" -}}
						{{- range $value := $field.Enum.Values -}}
							{{ if eq $value.Name "ID" }}
								if order.Sort == {{ $.GqlModels.PackageName }}.{{ $field.Enum.Name|go }}{{ .Name|go }} {
									handledID = true
								}
							{{ end }}
						{{- end -}}
					{{- end -}}
				{{- end -}}

				column := {{ .BoilerModel.Name }}SortColumn[order.Sort]
				if column != "" {
					a = append(a, qm.OrderBy(base_helpers.GetOrderBy(
						column,
						base_helpers.GetDirection(order.Direction, reverse),
					)))
				}
			}
			if !handledID {
				a = append(a, qm.OrderBy(base_helpers.GetOrderBy(
					{{ $.BoilerModels.PackageName }}.{{ $model.BoilerModel.Name }}Columns.ID,
					base_helpers.GetDirection(defaultDirection, reverse),
				)))
			}
			return a
		}


		func {{ .BoilerModel.Name }}PaginationModsBase(pagination base_helpers.ConnectionPagination, ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering, reverse bool, limit int) (*string, []qm.QueryMod) {
			direction := {{ .BoilerModel.Name }}SortDirection(ordering)
			cursor := base_helpers.GetCursor(pagination.Forward, pagination.Backward)
			sign := base_helpers.GetComparison(pagination.Forward, pagination.Backward, reverse, direction)

			var mods []qm.QueryMod
			mods = append(mods, {{ .BoilerModel.Name }}CursorMods(ordering, cursor, sign)...)
			mods = append(mods, {{ .BoilerModel.Name }}SortMods(ordering, reverse, direction)...)
			mods = append(mods, qm.Limit(limit))
			return cursor, mods
		}

		func {{ .BoilerModel.Name }}PaginationMods(pagination base_helpers.ConnectionPagination, ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering) ([]qm.QueryMod, error) {
			if pagination.Forward != nil && pagination.Backward != nil {
				return nil, errors.New("can not use forward and backward pagination at once")
			}
			if pagination.Forward == nil && pagination.Backward == nil {
				return nil, errors.New("no forward or backward pagination provided")
			}
		
			reverse := pagination.Backward != nil
			limit := base_helpers.GetLimit(pagination.Forward, pagination.Backward)
			_, mods := {{ .BoilerModel.Name }}PaginationModsBase(pagination, ordering, reverse, limit)
			return mods, nil
		}

		func To{{ .BoilerModel.Name }}CursorSwitch(ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering, m *{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}, cursorType base_helpers.CursorType, offset int, index int) string {
			switch cursorType {
			case base_helpers.CursorTypeOffset:
				return base_helpers.ToOffsetCursor(offset + index)
			case base_helpers.CursorTypeCursor:
				return To{{ .BoilerModel.Name }}Cursor(ordering, m)
			}
			return ""
		}

		func {{ .BoilerModel.Name }}ReversePageInformation(
			ctx context.Context,
			db *sql.Tx,
			pagination base_helpers.ConnectionPagination,
			ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering,
		) (bool, error) {
			reverse := pagination.Forward != nil
			cursor, reverseMods := {{ .BoilerModel.Name }}PaginationModsBase(pagination, ordering, reverse, 1)
			cursorType := {{ .BoilerModel.Name }}CursorType(ordering)
			return base_helpers.HasReversePage(cursor, pagination, cursorType, func() (int64, error) {
				return {{ $.BoilerModels.PackageName }}.{{ .BoilerModel.PluralName }}(reverseMods...).Count(ctx, db)
			})
		}

		func {{ .BoilerModel.Name }}EdgeConverter(pagination base_helpers.ConnectionPagination, ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering) func(*{{ $.BoilerModels.PackageName }}.{{ .BoilerModel.Name }}, int) *{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Edge {
			cursor, cursorType := base_helpers.GetCursor(pagination.Forward, pagination.Backward), {{ .BoilerModel.Name }}CursorType(ordering)
			offset := base_helpers.GetOffsetFromCursor(cursor)
			return func(m *{{ $.BoilerModels.PackageName }}.{{ .BoilerModel.Name }}, i int) *{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Edge {
				n := {{ .BoilerModel.Name }}ToGraphQL(m)
				return &{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Edge{
					Cursor: To{{ .BoilerModel.Name }}CursorSwitch(ordering, n, cursorType, offset, i),
					Node:   n,
				}
			}
		}

		func {{ .BoilerModel.Name }}StartEndCursor(edges []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Edge) (*string, *string) {
			var startCursor, endCursor *string
			if len(edges) >= 2 {
				s, e := edges[0].Cursor, edges[len(edges)-1].Cursor
				startCursor = &s
				endCursor = &e
			} else if len(edges) == 1 {
				c := edges[0].Cursor
				startCursor = &c
				endCursor = &c
			}
			return startCursor, endCursor
		}

		func {{ .BoilerModel.Name }}Connection(
			ctx context.Context,
			db *sql.Tx,
			originalMods []qm.QueryMod,
			pagination base_helpers.ConnectionPagination,
			ordering []*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Ordering,
		) (*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Connection, error) {
			paginationMods, err := {{ .BoilerModel.Name }}PaginationMods(pagination, ordering)
			if err != nil {
				return nil, err
			}
		
			hasMoreReversed, err := {{ .BoilerModel.Name }}ReversePageInformation(ctx, db, pagination, ordering)
			if err != nil {
				return nil, err
			}
		
			a, err := {{ $.BoilerModels.PackageName }}.{{ .BoilerModel.PluralName }}(append(originalMods, paginationMods...)...).All(ctx, db)
			if err != nil {
				return nil, err
			}
			edges := make([]*{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Edge, 0, base_helpers.EdgeLength(pagination, len(a)))
			edgeConverter := {{ .BoilerModel.Name }}EdgeConverter(pagination, ordering)
			hasMore := base_helpers.BaseConnection(pagination, len(a), func(i int) {
				edges = append(edges, edgeConverter(a[i], i))
			})
			startCursor, endCursor := {{ .BoilerModel.Name }}StartEndCursor(edges)
			hasNextPage, hasPreviousPage := base_helpers.HasNextAndPreviousPage(pagination, hasMore, hasMoreReversed)
			return &{{ $.GqlModels.PackageName }}.{{ .BoilerModel.Name }}Connection{
				Edges: edges,
				PageInfo: &{{ $.GqlModels.PackageName }}.PageInfo{
					HasNextPage:     hasNextPage,
					HasPreviousPage: hasPreviousPage,
					StartCursor:     startCursor,
					EndCursor:       endCursor,
				},
			}, nil
		}

    {{ end }}
{{ end }}
