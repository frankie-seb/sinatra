// Code generated by Frankie Health Generator, DO NOT EDIT.

package {{.PackageName}}

import (
	"context"
	"fmt"
	"io"
	"strconv"
	"time"
	"sync"
	"errors"
	"bytes"
	"strings"

	base_helpers "github.com/frankie-seb/sinatra/helpers"
	"github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"


	"github.com/ericlagergren/decimal"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/null/v8"

	"database/sql"
	{{ range $import := .Imports }}
		{{ $import.Alias }} "{{ $import.ImportPath }}"
	{{ end }}
)



{{ range $model := .Models }}

	{{- if .IsInput }}
				
		func {{ .PluralName }}ToBoiler(am []*{{ $.GqlModels.PackageName }}.{{ .Name }})( []*{{ $.BoilerModels.PackageName }}.{{ .BoilerModel.Name }}) {
			ar := make([]*{{ $.BoilerModels.PackageName }}.{{ .BoilerModel.Name }}, len(am))
			for i,m := range am {
				ar[i] = {{ .Name }}ToBoiler(
					m,
				)
			}
			return ar
		}
		
		func {{ .Name }}ToBoiler(
				m *{{ $.GqlModels.PackageName }}.{{ .Name }},
			)( *{{ $.BoilerModels.PackageName }}.{{ .BoilerModel.Name }}) {
			if m == nil {
				return nil
			}

			r := &{{ $.BoilerModels.PackageName }}.{{ .BoilerModel.Name }}{
			{{ range $field := .Fields -}}
				{{- if $field.ConvertConfig.IsCustom -}}
					{{- if $field.IsPrimaryID -}}
						{{- $field.BoilerField.Name }} : {{ $field.ConvertConfig.ToBoiler }},
					{{- else if and $field.IsNumberID $field.BoilerField.IsRelation -}}
						{{- $field.BoilerField.Name }} : {{ $field.ConvertConfig.ToBoiler }},
					{{- else if $field.IsRelation -}}
					{{- else -}}
						{{- $field.BoilerField.Name }} : {{ $field.ConvertConfig.ToBoiler }}(m.{{ $field.Name }}),
					{{- end }}
				{{- else if $field.IsRelation -}}
				{{- else -}}
					{{- $field.BoilerField.Name }}: m.{{ $field.Name }},
				{{- end }}
			{{ end }}
			}
			return r
		}

		func {{ .Name }}ToModelM(
			input map[string]interface{},
			m {{ $.GqlModels.PackageName }}.{{ .Name }},
		) {{ $.BoilerModels.PackageName }}.M {
			model := {{ .Name }}ToBoiler(&m)
			modelM := {{ $.BoilerModels.PackageName }}.M{}
			for key := range input {
				switch key {
					{{ range $field := .Fields -}}
					case "{{ $field.JSONName }}":
						modelM[{{ $.BoilerModels.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{- $field.BoilerField.Name }}] = model.{{ $field.Name }}
					{{ end -}}
				}
			}
			return modelM
		}
		
		func {{ .Name }}ToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
			var columnsWhichAreSet []string
			for key := range input {
				switch key {
					{{ range $field := .Fields -}}
						case "{{ $field.JSONName }}":
							columnsWhichAreSet = append(columnsWhichAreSet, {{ $.BoilerModels.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{- $field.BoilerField.Name }})
					{{ end -}}
				}
			}
			columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
			return boil.Whitelist(columnsWhichAreSet...)
		}
	{{- end }}
{{- end }}
