// Code generated by Frankie Health Generator, DO NOT EDIT.

package {{.PackageName}}

import (
	"context"
	"fmt"
	"io"
	"strconv"
	"time"
	"sync"
	"errors"
	"bytes"
	"strings"

	"github.com/ericlagergren/decimal"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/null/v8"

	base_helpers "github.com/FrankieHealth/be-base/helpers"
	"github.com/FrankieHealth/be-base/middleware"

	"github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/rs/zerolog/log"
	{{ range $import := $.Imports }}
		{{ $import.Alias }} "{{ $import.ImportPath }}"
	{{ end }}
)

{{ range $resolver := .Resolvers -}}

	{{- if .IsBatchCreate -}}
	//
	{{- end -}}
	
	{{ if and .IsSingle $.IsFederatedServer }}
		func (r *entityResolver) Find{{ .Model.Name }}ByID{{ $.ShortResolverDeclaration  $resolver }}  {
			return &fm.{{ .Model.Name }}{
				ID: id,
			}, nil
		}
	{{ end }}

	{{- if not .IsIgnore }}
	const {{ $resolver.PublicErrorKey }} = "{{ $resolver.PublicErrorMessage }}"

	func (r *{{lcFirst $resolver.Object.Name}}{{ucFirst $.ResolverType}}) {{$resolver.Field.GoFieldName}}{{ $.ShortResolverDeclaration  $resolver }}  {

		{{- if .IsSingle }}
			dbID := {{ .Model.Name }}ID(id)
			mods := Get{{ .Model.Name }}PreloadMods(ctx)
			mods = append(mods, dm.{{ .Model.Name }}Where.ID.EQ(dbID))
			{{ range $scope := $.AuthorizationScopes -}}
				{{- if (call $scope.AddHook $resolver.Model.BoilerModel $resolver "singleWhere") }}
					mods = append(mods, dm.{{ $resolver.Model.Name }}Where.{{ $scope.BoilerColumnName }}.EQ({{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)))
				{{- end }}
			{{- end }}

			m, err := dm.{{ .Model.PluralName }}(mods...).One(ctx, middleware.GetTx(ctx, false))
			if err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}
			return {{ .Model.Name }}ToGraphQL(m), nil

		{{- end -}}

		{{- if .IsList }}
			mods := Get{{ .Model.Name }}NodePreloadMods(ctx)
			{{ range $scope := $.AuthorizationScopes -}}
				{{- if (call $scope.AddHook $resolver.Model.BoilerModel $resolver "listWhere")   }}
					mods = append(mods, dm.{{ $resolver.Model.Name }}Where.{{ $scope.BoilerColumnName }}.EQ({{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)))
				{{- end }}
			{{- end }}

			mods = append(mods, {{.Model.Name}}FilterToMods(filter)...)
			{{- if .IsListBackward }}
				connection, err := {{.Model.Name}}Connection(ctx, middleware.GetTx(ctx, false), mods, base_helpers.NewBackwardPagination(last, before), ordering)
			{{- else }}
				connection, err := {{.Model.Name}}Connection(ctx, middleware.GetTx(ctx, false), mods, base_helpers.NewForwardPagination(first, after), ordering)
			{{- end }}
			if err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}
			return connection, nil
		{{- end -}}

		{{- if .IsCreate }}

			m := {{ .InputModel.Name }}ToBoiler(&input)
			{{ $model := .Model -}}
			{{ range $field := .InputModel.Fields -}}
				{{ if and $field.IsObject $field.BoilerField.IsRelation -}}
					if input.{{ $field.Name }} != nil {
						{{ $field.JSONName }} := {{ $field.BoilerField.Relationship.Name }}CreateInputToBoiler(input.{{ $field.Name }})
						{{ range $scope := $.AuthorizationScopes -}}
							{{- if (call $scope.AddHook $field.BoilerField.Relationship $resolver "createRelationInput")   }}
								{{ $field.JSONName }}.{{ $scope.BoilerColumnName }} = {{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)
							{{- end }}
						{{- end }}

						// TODO: create the nested relations of {{ $field.Name }}Input if they exist
						if err := {{ $field.JSONName }}.Insert(ctx, middleware.GetTx(ctx, true), boil.Infer()); err != nil {
							log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
							return nil, errors.New({{ $resolver.PublicErrorKey }})
						}
						m.{{ $field.Name }}ID = {{ $field.JSONName }}.ID
					}

				{{ end -}}
			{{ end -}}

			{{ range $scope := $.AuthorizationScopes -}}
				{{- if (call $scope.AddHook $resolver.Model.BoilerModel $resolver "createInput")   }}
					m.{{$scope.BoilerColumnName}} = {{$scope.ImportAlias}}.{{$scope.ScopeResolverName}}(ctx)
				{{- end }}
			{{- end }}

			if err := m.Insert(ctx, middleware.GetTx(ctx, true), boil.Infer()); err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}

			// resolve requested fields after creating
			mods := Get{{ .Model.Name }}PreloadModsWithLevel(ctx, {{ .Model.Name }}PayloadPreloadLevels.{{ .Model.Name }})
			mods = append(mods, dm.{{ .Model.Name }}Where.ID.EQ(m.ID))
			pM, err := dm.{{ .Model.PluralName }}(mods...).One(ctx, middleware.GetTx(ctx, false))
			if err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}
			return &fm.{{ .Model.Name }}Payload{
				{{ .Model.Name }}: {{ .Model.Name }}ToGraphQL(pM),
			}, nil

		{{- end -}}

		{{- if .IsUpdate }}
			m := {{ .InputModel.Name }}ToModelM(base_helpers.GetInputFromContext(ctx, inputKey), input)

			{{ $resolver := . -}}
			{{ $model := .Model -}}
			{{ range $field := .InputModel.Fields -}}
				{{ if and $field.IsObject $field.BoilerField.IsRelation -}}
					if input.{{ $field.Name }} != nil && input.{{ $field.Name }}ID != nil {
						dbID := {{ $field.BoilerField.Relationship.Name }}ID(*input.{{ $field.Name }}ID)
						nestedM := {{ $field.BoilerField.Relationship.Name }}UpdateInputToModelM(
							base_helpers.GetInputFromContext(ctx, "input.{{ $field.JSONName }}"),
							*input.{{ $field.Name }},
						)
						if _, err := dm.{{ $field.BoilerField.Relationship.PluralName }}(
							dm.{{ $field.BoilerField.Relationship.Name }}Where.ID.EQ(dbID),
							{{ range $scope := $.AuthorizationScopes -}}
								{{- if (call $scope.AddHook $field.BoilerField.Relationship $resolver "updateRelationWhere")   }}
									dm.{{ $field.BoilerField.Relationship.Name }}Where.{{ $scope.BoilerColumnName }}.EQ(
										{{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx),
									),
								{{- end }}
							{{- end }}
						).UpdateAll(ctx, middleware.GetTx(ctx, true), nestedM); err != nil {
							log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
							return nil, errors.New({{ $resolver.PublicErrorKey }})
						}
					}

				{{ end -}}
			{{ end -}}

			dbID := {{ .Model.Name }}ID(id)
			if _, err := dm.{{ .Model.PluralName }}(
				dm.{{ .Model.Name }}Where.ID.EQ(dbID),
				{{ range $scope := $.AuthorizationScopes -}}
					{{- if (call $scope.AddHook $resolver.Model.BoilerModel $resolver "updateWhere")   }}
						dm.{{ $resolver.Model.Name }}Where.{{ $scope.BoilerColumnName }}.EQ({{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)),
					{{- end }}
				{{- end }}
			).UpdateAll(ctx, middleware.GetTx(ctx, true), m); err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}

			// resolve requested fields after updating
			mods := Get{{ .Model.Name }}PreloadModsWithLevel(ctx, {{ .Model.Name }}PayloadPreloadLevels.{{ .Model.Name }})
			mods = append(mods, dm.{{ .Model.Name }}Where.ID.EQ(dbID))
			{{ range $scope := $.AuthorizationScopes -}}
				{{- if (call $scope.AddHook $resolver.Model.BoilerModel $resolver "updateAfterWhere")   }}
					mods = append(mods, dm.{{ $resolver.Model.Name }}Where.{{ $scope.BoilerColumnName }}.EQ({{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)))
				{{- end }}
			{{- end }}

			pM, err := dm.{{ .Model.PluralName }}(mods...).One(ctx, middleware.GetTx(ctx, false))
			if err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}
			return &fm.{{ .Model.Name }}Payload{
				{{ .Model.Name }}: {{ .Model.Name }}ToGraphQL(pM),
			}, nil

		{{- end -}}

		{{- if .IsDelete }}
			dbID := {{ .Model.Name }}ID(id)
			mods := []qm.QueryMod{
				dm.{{ .Model.Name }}Where.ID.EQ(dbID),
				{{ range $scope := $.AuthorizationScopes -}}
					{{- if (call $scope.AddHook $resolver.Model.BoilerModel $resolver "deleteWhere")   }}
						dm.{{ $resolver.Model.Name }}Where.{{ $scope.BoilerColumnName }}.EQ(
							{{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx),
						),
					{{- end }}
				{{- end }}
			}
			 if _, err := dm.{{ .Model.PluralName }}(mods...).DeleteAll(ctx, middleware.GetTx(ctx, true){{- if $.SoftDelete }}, false {{ end -}}); err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}

			return &fm.{{ .Model.Name }}DeletePayload{
				ID: id,
			}, nil

		{{- end -}}

		{{- if .IsBatchCreate }}
		// TODO: Implement batch create
		return nil, nil

		{{- end -}}

		{{- if .IsBatchUpdate }}
			var mods []qm.QueryMod
			{{ range $scope := $.AuthorizationScopes -}}
				{{- if (call $scope.AddHook $resolver.Model.BoilerModel $resolver "batchUpdateWhere")   }}
					mods = append(mods, dm.{{ $resolver.Model.Name }}Where.{{ $scope.BoilerColumnName }}.EQ({{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)))
				{{- end }}
			{{- end }}
			mods = append(mods, {{.Model.Name}}FilterToMods(filter)...)

			m := {{ .InputModel.Name }}ToModelM(base_helpers.GetInputFromContext(ctx, inputKey), input)
			if _, err := dm.{{ .Model.PluralName }}(mods...).UpdateAll(ctx, middleware.GetTx(ctx, true), m); err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}

			return &fm.{{ .Model.PluralName }}UpdatePayload{
				Ok: true,
			}, nil
		{{- end -}}

		{{- if .IsBatchDelete }}
			var mods []qm.QueryMod
			{{ range $scope := $.AuthorizationScopes -}}
				{{- if (call $scope.AddHook $resolver.Model.BoilerModel $resolver "batchDeleteWhere")   }}
					mods = append(mods, dm.{{ $resolver.Model.Name }}Where.{{ $scope.BoilerColumnName }}.EQ({{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)))
				{{- end }}
			{{- end }}
			mods = append(mods, {{.Model.Name}}FilterToMods(filter)...)
			mods = append(mods, qm.Select(dm.{{ .Model.Name }}Columns.ID))
			mods = append(mods, qm.From(dm.TableNames.{{ .Model.BoilerModel.TableName }}))

			{{- if .Model.HasPrimaryStringID }}
			var IDsToRemove []base_helpers.RemovedStringID
			{{- else }}
			var IDsToRemove []base_helpers.RemovedID
			{{- end }}
			if err := dm.{{ .Model.PluralName }}(mods...).Bind(ctx, middleware.GetTx(ctx, false), &IDsToRemove); err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}

			boilerIDs := base_helpers.RemovedIDsToBoiler{{.Model.PrimaryKeyType|go}}(IDsToRemove)
			if _, err := dm.{{ .Model.PluralName }}(dm.{{ .Model.Name }}Where.ID.IN(boilerIDs)).DeleteAll(ctx, middleware.GetTx(ctx, true){{- if $.SoftDelete }}, false {{ end -}}); err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}

			return &fm.{{ .Model.PluralName }}DeletePayload{
				Ids: base_helpers.{{.Model.PrimaryKeyType|go}}IDsToGraphQL(boilerIDs, dm.TableNames.{{ .Model.BoilerModel.TableName }}),
			}, nil
		{{- end }}
	}
	{{- end }}

{{ end }}