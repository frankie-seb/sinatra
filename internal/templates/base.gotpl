// Code generated by Frankie Health Generator, DO NOT EDIT.

package {{.PackageName}}

import (
	"context"
	"fmt"
	"io"
	"strconv"
	"time"
	"sync"
	"errors"
	"bytes"
	"strings"

	base_helpers "github.com/FrankieHealth/be-base/helpers"
	"github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"


	"github.com/ericlagergren/decimal"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/null/v8"

	"database/sql"
	{{ range $import := .Imports }}
		{{ $import.Alias }} "{{ $import.ImportPath }}"
	{{ end }}
)

const batchInsertStatement = "INSERT INTO %s (%s) VALUES %s"

{{ range $enum := .Enums }}

	{{- if $enum.HasBoilerEnum }}
	var {{$enum.Name}}DBValue = map[{{ $.GqlModels.PackageName }}.{{ .Name }}]string{
		{{- range $value := .Values }}
			{{- if .BoilerEnumValue }}
				{{ $.GqlModels.PackageName }}.{{$enum.Name|go}}{{ .Name|go }}: {{ $.BoilerModels.PackageName }}.{{ .BoilerEnumValue.Name }},
			{{- end }}
		{{- end }}
	}
	var {{$enum.Name}}APIValue = map[string]{{ $.GqlModels.PackageName }}.{{ .Name }}{
		{{- range $value := .Values }}
			{{- if .BoilerEnumValue }}
				{{ $.BoilerModels.PackageName }}.{{ .BoilerEnumValue.Name }}: {{ $.GqlModels.PackageName }}.{{$enum.Name|go}}{{ .Name|go }},
			{{- end }}
		{{- end }}
	}
	{{- else }}
		type {{$enum.Name}} string
		const (
			{{- range $value := .Values }}
				{{$enum.Name|go}}{{ .Name|go }}        {{$enum.Name}} = "{{ .NameLower }}"
			{{- end }}
		)

		var {{$enum.Name}}DBValue = map[{{ $.GqlModels.PackageName }}.{{ .Name }}]{{$enum.Name}}{
			{{- range $value := .Values }}
				{{ $.GqlModels.PackageName }}.{{$enum.Name|go}}{{ .Name|go }}: {{$enum.Name|go}}{{ .Name|go }},
			{{- end }}
		}

		var {{$enum.Name}}APIValue = map[{{$enum.Name}}]{{ $.GqlModels.PackageName }}.{{ .Name }}{
			{{- range $value := .Values }}
				{{$enum.Name|go}}{{ .Name|go }}: {{ $.GqlModels.PackageName }}.{{$enum.Name|go}}{{ .Name|go }},
			{{- end }}
		}
	{{- end }}
{{ end }}

{{ range $model := .Models }}
	{{- if .IsInput -}}
		func {{ .Name }}ToBoiler(
				m *{{ $.GqlModels.PackageName }}.{{ .Name }},
			)( *{{ $.BoilerModels.PackageName }}.{{ .BoilerModel.Name }}) {
			if m == nil {
				return nil
			}

			r := &{{ $.BoilerModels.PackageName }}.{{ .BoilerModel.Name }}{
			{{ range $field := .Fields -}}
				{{- if $field.ConvertConfig.IsCustom -}}
					{{- if $field.IsPrimaryID -}}
						{{- $field.BoilerField.Name }}: {{ $field.ConvertConfig.ToBoiler }},
					{{- else if and $field.IsNumberID $field.BoilerField.IsRelation -}}
						{{- $field.BoilerField.Name }}: {{ $field.ConvertConfig.ToBoiler }},
					{{- else if and $field.IsNumberID $field.IsID -}}
						{{- $field.BoilerField.Name }}: {{ $field.ConvertConfig.ToBoiler }},
					{{- else if $field.IsRelation -}}
						{{- $field.BoilerField.Name }}: {{ $field.ConvertConfig.ToBoiler }}(m.{{ $field.Name }}),
					{{- else -}}
						{{- $field.BoilerField.Name }}: {{ $field.ConvertConfig.ToBoiler }}(m.{{ $field.Name }}),
					{{- end }}
				{{- else if $field.IsRelation -}}
					{{- $field.BoilerField.Name }} : {{ $field.ConvertConfig.ToBoiler }}(m.{{ $field.Name }}),
				{{- else -}}
					{{- $field.BoilerField.Name }}: m.{{ $field.Name }},
				{{- end }}
			{{ end }}
			}
			return r
		}

		func {{ .Name }}ToModelM(
			input map[string]interface{},
			m {{ $.GqlModels.PackageName }}.{{ .Name }},
		) {{ $.BoilerModels.PackageName }}.M {
			model := {{ .Name }}ToBoiler(&m)
			modelM := {{ $.BoilerModels.PackageName }}.M{}
			for key := range input {
				switch key {
					{{ range $field := .Fields -}}
					case "{{ $field.JSONName }}":
						modelM[{{ $.BoilerModels.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{- $field.BoilerField.Name }}] = model.{{ $field.Name }}
					{{ end -}}
				}
			}
			return modelM
		}
		
		func {{ .Name }}ToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
			var columnsWhichAreSet []string
			for key := range input {
				switch key {
					{{ range $field := .Fields -}}
						case "{{ $field.JSONName }}":
							columnsWhichAreSet = append(columnsWhichAreSet, {{ $.BoilerModels.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{- $field.BoilerField.Name }})
					{{ end -}}
				}
			}
			columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
			return boil.Whitelist(columnsWhichAreSet...)
		}
	{{ end }}
	{{- if .IsNormal  -}}
		func {{ .Name }}ToGraphQL(m *{{ $.BoilerModels.PackageName }}.{{ .BoilerModel.Name }})( *{{ $.GqlModels.PackageName }}.{{ .Name }}) {
			if m == nil {
				return nil
			}

			r := &{{ $.GqlModels.PackageName }}.{{ .Name }}{
				{{ range $field := .Fields -}}
					{{- if $field.ConvertConfig.IsCustom -}}
						{{- if $field.IsPrimaryID -}}
							{{- $field.Name }}: {{ $field.ConvertConfig.ToGraphQL }},
						{{- else if and $field.IsNumberID $field.BoilerField.IsRelation -}}
							{{- $field.Name }}: {{ $field.ConvertConfig.ToGraphQL }},
						{{- else if and $field.IsNumberID $field.IsID -}}
							{{- $field.Name }}: {{ $field.ConvertConfig.ToGraphQL }},
						{{- else if $field.IsRelation -}}
						// {{- $field.Name }}: ????
						{{- else -}}
							{{- $field.Name }}: {{ $field.ConvertConfig.ToGraphQL }}(m.{{ $field.BoilerField.Name }}),
						{{- end }}
					{{- else if $field.IsRelation -}}
					{{- else -}}
						{{- $field.Name }}: m.{{ $field.BoilerField.Name }},
					{{- end }}
				{{ end }}
			}

			{{ range $field := .Fields }}
		
				{{- if $field.IsRelation }}

					{{- if $field.IsPlural }}
						if m.R != nil && m.R.{{ $field.Name }} != nil  {
							r.{{ $field.Name }} = {{ $field.BoilerField.Relationship.PluralName }}ToGraphQL(m.R.{{ $field.Name }})
						} 
					{{- else }}
						{{- if $field.BoilerField.IsForeignKey }}
							if base_helpers.{{ $field.ConvertConfig.BoilerTypeAsText }}IsFilled(m.{{ $field.Name }}ID) {
								if m.R != nil && m.R.{{ $field.Name }} != nil  {
									r.{{ $field.Name }} = {{ $field.BoilerField.Relationship.Name }}ToGraphQL(m.R.{{ $field.Name }})
								} else {
									r.{{ $field.Name }} = {{ $field.BoilerField.Relationship.Name }}With{{ $field.ConvertConfig.BoilerTypeAsText }}ID(m.{{ $field.Name }}ID)
								}
							}
						{{- else }}
							if m.R != nil && m.R.{{ $field.Name }} != nil  {
								r.{{ $field.Name }} = {{ $field.BoilerField.Relationship.Name }}ToGraphQL(m.R.{{ $field.Name }})
							}
						{{- end -}}
					{{- end -}}
				{{end -}}
			{{- end }}

			return r
		}
	{{ end }}
	{{- if .IsWhere  -}}	
		func {{ .Name }}ToMods(m *{{ $.GqlModels.PackageName }}.{{ .Name }}, withPrimaryID bool, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			{{ $model := . }}
			{{ range $field := .Fields }}
				{{- if not $field.IsJSON -}}
					{{-  if and $field.IsRelation $field.BoilerField.IsRelation }}
						{{- if $field.IsPlural }}
							queryMods = append(queryMods, {{ $field.TypeWithoutPointer|go }}SubqueryToMods(m.{{ $field.Name }}, "", {{ $.BoilerModels.PackageName }}.TableNames.{{- $model.BoilerModel.TableName }})...)
						{{- else if $field.BoilerField.IsForeignKey }}
							queryMods = append(queryMods, {{ $field.TypeWithoutPointer|go }}SubqueryToMods(m.{{ $field.Name }}, {{ $.BoilerModels.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{ $field.BoilerField.Name }}, {{ $.BoilerModels.PackageName }}.TableNames.{{- $model.BoilerModel.TableName }})...)
						{{- else }}
							queryMods = append(queryMods, {{ $field.TypeWithoutPointer|go }}SubqueryToMods(m.{{ $field.Name }}, "", {{ $.BoilerModels.PackageName }}.TableNames.{{- $model.BoilerModel.TableName }})...)
						{{- end }}
					{{-  else if $field.IsOr  }}
						if m.Or != nil {
							queryMods = append(queryMods, qm.Or2(qm.Expr({{ $field.TypeWithoutPointer|go }}ToMods(m.Or, true, "")...)))
						}
					{{-  else if $field.IsAnd  }}
						if m.And != nil {
							queryMods = append(queryMods, qm.Expr({{ $field.TypeWithoutPointer|go }}ToMods(m.And, true, "")...))
						}
					{{- else }}
						{{- if $field.IsPrimaryID }}
						if withPrimaryID {
							queryMods = append(queryMods, {{ $field.TypeWithoutPointer|go }}ToMods(m.{{ $field.Name }}, {{ $.BoilerModels.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{ $field.BoilerField.Name }})...)
						}
						{{- else }}
							queryMods = append(queryMods, {{ $field.TypeWithoutPointer|go }}ToMods(m.{{ $field.Name }}, {{ $.BoilerModels.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{ $field.BoilerField.Name }})...)					
						{{- end }}
					{{- end -}}
				{{ end }}
			{{ end }}

			if len(queryMods) > 0 && parentTable != "" {
				{{ range $field := .Fields }}
					{{- if not $field.IsPlural -}}
						{{-  if and $field.IsRelation $field.BoilerField.IsRelation  -}}
							{{- if $field.BoilerField.IsForeignKey }}
								if parentTable == {{ $.BoilerModels.PackageName }}.TableNames.{{ $field.Relationship.BoilerModel.TableName }} {
									queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", {{ $.BoilerModels.PackageName }}.TableNames.{{- $model.BoilerModel.TableName }}, {{ $.BoilerModels.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{ $field.BoilerField.Name }}, parentTable)))
								}
							{{- else }}
								// TODO: if the relations filtering does not work, please make an issue
								// if parentTable == {{ $.BoilerModels.PackageName }}.TableNames.{{ $field.Relationship.BoilerModel.TableName }} {
									// queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", {{ $.BoilerModels.PackageName }}.TableNames.{{- $model.BoilerModel.TableName }}, {{ $.BoilerModels.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{ $field.BoilerField.Name }}, parentTable)))
								// }
							{{- end -}}
						{{- end -}}
					{{- end -}}
				{{ end }}
			}



			return queryMods
		}
	{{ end }}
	{{- if .IsOrdering -}}

		{{- range $field := .Fields -}}
			{{- if eq $field.Name "Sort" -}}
				var {{ $field.Enum.Name }}Column = map[{{ $.GqlModels.PackageName }}.{{$field.Enum.Name}}]string{
					{{- range $value := $field.Enum.Values}}
						{{- if eq $value.Name "RANDOM" -}}
						{{- else }}
							{{ $.GqlModels.PackageName }}.{{ $field.Enum.Name|go }}{{ .Name|go }}: {{ $.BoilerModels.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{ $value.NameLower|go }},
						{{- end -}}
					{{- end }}
				}

				func {{ $model.BoilerModel.Name }}SortValueFromCursorValue(cursorValue string) (string, interface{}) {
					key, value := base_helpers.FromCursorValue(cursorValue)
					column := {{ $model.BoilerModel.Name }}SortColumn[{{ $.GqlModels.PackageName }}.{{ $model.BoilerModel.Name }}Sort(key)]


					{{ range $value := $field.Enum.Values}}
						{{- if eq $value.Name "ID" -}}
						if {{ $.GqlModels.PackageName }}.{{ $field.Enum.Name|go }}(key) == {{ $.GqlModels.PackageName }}.{{ $field.Enum.Name|go }}{{ .Name|go }} {
							return column, base_helpers.GetIDFromCursor(value)
						}
						{{- end -}}
					{{ end }}

					return column, base_helpers.StringToInterface(value)
				}

				func {{ $model.BoilerModel.Name }}SortCursorValue(sort {{ $.GqlModels.PackageName }}.{{ $model.BoilerModel.Name }}Sort, m *{{ $.GqlModels.PackageName }}.{{ $model.BoilerModel.Name }}) interface{} {
					switch sort {
					{{- range $value := $field.Enum.Values }}
						{{- if eq $value.Name "RANDOM" -}}
						{{- else }}
						case {{ $.GqlModels.PackageName }}.{{ $field.Enum.Name|go }}{{ .Name|go }}:
						return m.{{ .NameLower|go }}
						{{- end -}}
					{{- end }}
					}
					return nil
				}
			{{ end }}
		{{- end }}
    {{ end }}
	{{ if .IsCreateInput  }}
		var {{ lcFirst .BoilerModel.PluralName }}BatchCreateColumns = []string{
			{{ range $field := .Fields -}}
				{{ $.BoilerModels.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{- $field.BoilerField.Name }},
			{{ end }}
		}

		var {{ lcFirst .BoilerModel.PluralName }}BatchCreateColumnsMarks = base_helpers.GetQuestionMarksForColumns({{ lcFirst .BoilerModel.PluralName }}BatchCreateColumns)

		func {{ lcFirst .BoilerModel.Name }}ToBatchCreateValues(e *{{ $.BoilerModels.PackageName }}.{{ .BoilerModel.Name }}) []interface{} {
			return []interface{}{
				{{ range $field := .Fields -}}
					e.{{- $field.BoilerField.Name }},
				{{ end }}
			}
		}

		func {{ lcFirst .BoilerModel.PluralName }}ToBatchCreate(a []*{{ $.BoilerModels.PackageName }}.{{ .BoilerModel.Name }}) ([]string, []interface{}) {
			queryMarks := make([]string, len(a))
			// nolint:prealloc
			// yes?
			var values []interface{}
			for i, boilerRow := range a {
				queryMarks[i] = {{ lcFirst .BoilerModel.PluralName }}BatchCreateColumnsMarks
				values = append(values, {{ lcFirst .BoilerModel.Name }}ToBatchCreateValues(boilerRow)...)
			}
			return queryMarks, values
		}

		func {{ .BoilerModel.PluralName }}ToBatchCreateQuery(a []*{{ $.BoilerModels.PackageName }}.{{ .BoilerModel.Name }}) (string, []interface{}) {
			queryMarks, values := {{ lcFirst .BoilerModel.PluralName }}ToBatchCreate(a)
			// nolint: gosec -> remove warning because no user input without questions marks
			return fmt.Sprintf(batchInsertStatement,
				{{ $.BoilerModels.PackageName }}.TableNames.{{ .BoilerModel.Name }},
				strings.Join({{ lcFirst .BoilerModel.PluralName }}BatchCreateColumns, ", "),
				strings.Join(queryMarks, ", "),
			), values
		}
	{{ end }}
{{- end }}